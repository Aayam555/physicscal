<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Young's Double Slit Simulation</title>
    <!-- Use Tailwind CSS for a clean, modern look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark charcoal background */
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        #scene-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 24px;
            background-color: rgba(45, 55, 72, 0.8); /* Semi-transparent dark gray */
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            gap: 16px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 250px;
        }

        .control-group label {
            font-size: 0.875rem;
            margin-bottom: 8px;
            color: #a0aec0; /* Lighter gray for labels */
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #4a5568; /* Gray track */
            outline: none;
            border-radius: 9999px;
            transition: background 0.3s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #63b3ed; /* Blue thumb */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }


        /* Message box styling */
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #f7fafc;
            color: #1a202c;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            max-width: 400px;
            text-align: center;
            font-size: 1rem;
        }

        .message-box-button {
            margin-top: 15px;
            padding: 10px 20px;
            border: none;
            background-color: #4a5568;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
     <div style="margin-top: 20px; margin-bottom: 20px;" id="home">
        <a href="../../index.html" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Home</a>
        <a href="../wavesAndOscillation.html" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Back</a>
    </div>
    <div id="scene-container">
        <canvas id="double-slit-canvas"></canvas>
    </div>

    <div id="controls">
        <div class="control-group">
            <label for="wavelength-slider">Wavelength (Î»)</label>
            <input type="range" id="wavelength-slider" min="0.1" max="5.0" step="0.01" value="1.0">
        </div>
        <div class="control-group">
            <label for="slit-distance-slider">Slit Distance (d)</label>
            <input type="range" id="slit-distance-slider" min="0.5" max="10.0" step="0.1" value="3.0">
        </div>
    </div>

    <div id="message-box">
        <p id="message-text"></p>
        <button class="message-box-button" onclick="document.getElementById('message-box').style.display = 'none';">OK</button>
    </div>

    <script>
        // Use a message box instead of alert()
        function showMessage(text) {
            const messageBox = document.getElementById('message-box');
            document.getElementById('message-text').innerText = text;
            messageBox.style.display = 'block';
        }

        window.onload = function() {
            try {
                // --- Three.js Scene Setup ---
                const canvas = document.getElementById('double-slit-canvas');
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);

                // Add a simple ambient light to the scene
                const ambientLight = new THREE.AmbientLight(0x404040, 2); // soft white light
                scene.add(ambientLight);

                // Camera position
                camera.position.set(0, 10, 25);
                camera.lookAt(0, 0, 0);

                // --- Simulation Parameters ---
                let wavelength = parseFloat(document.getElementById('wavelength-slider').value);
                let slitDistance = parseFloat(document.getElementById('slit-distance-slider').value);
                const slitZ = -10; // Position of the slits
                const screenZ = 20; // Position of the screen where interference is visible
                let time = 0;

                // Slit positions
                const slit1Pos = new THREE.Vector3(-slitDistance / 2, 0, slitZ);
                const slit2Pos = new THREE.Vector3(slitDistance / 2, 0, slitZ);

                // --- Shader for Wave Interference ---
                // The vertex shader simply passes position to the fragment shader
                const vertexShader = `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;

                // The fragment shader calculates the wave interference pattern
                const fragmentShader = `
                    uniform float time;
                    uniform float wavelength;
                    uniform float slitDistance;
                    varying vec3 vPosition;

                    void main() {
                        // Slit positions on the plane
                        vec3 slit1 = vec3(-slitDistance / 2.0, 0.0, 0.0);
                        vec3 slit2 = vec3(slitDistance / 2.0, 0.0, 0.0);
                        
                        // Calculate distances from the current fragment position to each slit
                        float d1 = distance(vPosition, slit1);
                        float d2 = distance(vPosition, slit2);
                        
                        // Calculate phase difference
                        // k = 2 * pi / lambda
                        float k = 6.28318530718 / wavelength; // 2 * pi
                        float phase1 = k * d1 - time;
                        float phase2 = k * d2 - time;

                        // Superposition of two waves (assuming simple cosine waves)
                        float amplitude1 = cos(phase1);
                        float amplitude2 = cos(phase2);
                        
                        float combinedAmplitude = amplitude1 + amplitude2;

                        // Convert amplitude to intensity (intensity is proportional to amplitude squared)
                        float intensity = pow(combinedAmplitude, 2.0);

                        // Normalize intensity to a 0-1 range and clamp it
                        intensity = clamp(intensity / 4.0, 0.0, 1.0);

                        // Use intensity to determine color: green for high intensity (constructive), black for low (destructive)
                        // A smooth step function helps create a sharper pattern
                        float patternValue = smoothstep(0.0, 0.2, intensity) - smoothstep(0.8, 1.0, intensity);
                        
                        vec3 color = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), patternValue); // Black to green gradient
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;

                // Create a shader material
                const interferenceMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0.0 },
                        wavelength: { value: wavelength },
                        slitDistance: { value: slitDistance }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
                });

                // Create the plane (the screen) where the interference pattern will be displayed
                const planeGeometry = new THREE.PlaneGeometry(50, 50, 100, 100);
                const plane = new THREE.Mesh(planeGeometry, interferenceMaterial);
                plane.rotation.x = -Math.PI / 2; // Orient the plane horizontally
                plane.position.set(0, 0, screenZ); // Position the plane in the scene
                scene.add(plane);

                // Create the two slits as small spheres
                const slitMaterial = new THREE.MeshBasicMaterial({ color: 0x63b3ed }); // Blue color
                const slitGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const slit1 = new THREE.Mesh(slitGeometry, slitMaterial);
                const slit2 = new THREE.Mesh(slitGeometry, slitMaterial);
                slit1.position.copy(slit1Pos);
                slit2.position.copy(slit2Pos);
                scene.add(slit1);
                scene.add(slit2);

                // --- User Interaction (Camera Control) ---
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                const rotationSpeed = 0.005;

                function onMouseDown(event) {
                    isDragging = true;
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }

                function onMouseMove(event) {
                    if (!isDragging) return;
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;

                    // Rotate the camera around the scene center
                    const newRotation = new THREE.Euler().copy(camera.rotation);
                    newRotation.y += deltaX * rotationSpeed;
                    newRotation.x += deltaY * rotationSpeed;
                    camera.rotation.copy(newRotation);

                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }

                function onMouseUp() {
                    isDragging = false;
                }
                
                // Add event listeners for mouse interaction
                renderer.domElement.addEventListener('mousedown', onMouseDown);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mouseup', onMouseUp);

                // --- Mobile Touch Controls ---
                let initialTouchPosition = { x: 0, y: 0 };

                function onTouchStart(event) {
                    // Check for a single touch to prevent multi-finger gestures from interfering
                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        isDragging = true;
                        // Store the initial touch position and update the previous mouse position
                        // to ensure smooth transition from mouse to touch
                        initialTouchPosition = { x: touch.clientX, y: touch.clientY };
                        previousMousePosition = initialTouchPosition;
                    }
                }

                function onTouchMove(event) {
                    // Only process if dragging and there's a single touch
                    if (!isDragging || event.touches.length !== 1) return;
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - previousMousePosition.x;
                    const deltaY = touch.clientY - previousMousePosition.y;

                    // Apply rotation, with a multiplier for a more responsive feel on mobile
                    const newRotation = new THREE.Euler().copy(camera.rotation);
                    newRotation.y += deltaX * rotationSpeed * 2.5;
                    newRotation.x += deltaY * rotationSpeed * 2.5;
                    camera.rotation.copy(newRotation);

                    // Update previous position for the next frame
                    previousMousePosition = { x: touch.clientX, y: touch.clientY };

                    // Prevent default scrolling behavior on mobile
                    event.preventDefault();
                }

                function onTouchEnd() {
                    isDragging = false;
                }

                // Add event listeners for touch interaction
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });


                // Handle window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // --- Animation Loop ---
                function animate() {
                    requestAnimationFrame(animate);

                    // Update time uniform for the shader
                    time += 0.05;
                    interferenceMaterial.uniforms.time.value = time;

                    renderer.render(scene, camera);
                }

                // Start the animation
                animate();

                // --- Control Listeners ---
                const wavelengthSlider = document.getElementById('wavelength-slider');
                const slitDistanceSlider = document.getElementById('slit-distance-slider');

                wavelengthSlider.oninput = function() {
                    wavelength = this.value;
                    interferenceMaterial.uniforms.wavelength.value = wavelength;
                };

                slitDistanceSlider.oninput = function() {
                    slitDistance = this.value;
                    interferenceMaterial.uniforms.slitDistance.value = slitDistance;

                    // Update slit positions to match the new distance
                    slit1.position.set(-slitDistance / 2, 0, slitZ);
                    slit2.position.set(slitDistance / 2, 0, slitZ);
                };

            } catch (error) {
                console.error("An error occurred:", error);
                showMessage("An error occurred while setting up the simulation. Please check the console for details.");
            }
        };
    </script>
</body>
</html>
